/*******************************************************************************
 * Copyright (c) 2009, 2017 Mountainminds GmbH & Co. KG and Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *
 *******************************************************************************/
package org.jacoco.core.internal.analysis.filter;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

/**
 * Filters code that is generated by a compiler for an assert statement.
 */
public final class AssertFilter implements IFilter {

	public void filter(final String className, final String superClassName,
			final MethodNode methodNode, final IFilterOutput output) {
		if (methodNode.name.equals("<clinit>")) {
			AbstractInsnNode i = methodNode.instructions.getFirst();
			while (i != null) {
				filterClinit(className, i, output);
				i = i.getNext();
			}
		}

		AbstractInsnNode i = methodNode.instructions.getFirst();
		while (i != null) {
			filter(className, i, output);
			i = i.getNext();
		}
	}

	private static void filterClinit(final String className,
			final AbstractInsnNode start, final IFilterOutput output) {
		if (start.getOpcode() == Opcodes.LDC) {
			final LdcInsnNode ldc = (LdcInsnNode) start;
			if (ldc.cst instanceof Type
					&& ((Type) ldc.cst).getInternalName().equals(className)) {
				final AbstractInsnNode to = new ClinitMatcher().match(className,
						start);
				if (to != null) {
					output.ignore(start, to);
				}
			}
		}
	}

	private static boolean isAssertionsDisabledField(final String className,
			final FieldInsnNode field) {
		return field.owner.equals(className)
				&& field.name.equals("$assertionsDisabled")
				&& field.desc.equals("Z");
	}

	private static class ClinitMatcher extends AbstractMatcher {
		AbstractInsnNode match(final String className,
				final AbstractInsnNode start) {
			cursor = start;
			nextIs(Opcodes.INVOKEVIRTUAL);
			final MethodInsnNode m = (MethodInsnNode) cursor;
			if (m == null || !m.owner.equals("java/lang/Class")
					|| !m.name.equals("desiredAssertionStatus")
					|| !m.desc.equals("()Z")) {
				return null;
			}
			nextIs(Opcodes.IFNE);
			if (cursor == null) {
				return null;
			}
			final LabelNode zeroLabel = ((JumpInsnNode) cursor).label;
			nextIs(Opcodes.ICONST_1);
			nextIs(Opcodes.GOTO);
			if (cursor == null) {
				return null;
			}
			final LabelNode putstaticLabel = ((JumpInsnNode) cursor).label;
			if (cursor.getNext() != zeroLabel) {
				return null;
			}
			nextIs(Opcodes.ICONST_0);
			if (cursor.getNext() != putstaticLabel) {
				return null;
			}
			nextIs(Opcodes.PUTSTATIC);
			if (cursor == null || !isAssertionsDisabledField(className,
					(FieldInsnNode) cursor)) {
				return null;
			}
			return cursor;
		}
	}

	private static void filter(final String className,
			final AbstractInsnNode start, final IFilterOutput output) {
		if (start.getOpcode() == Opcodes.GETSTATIC && isAssertionsDisabledField(
				className, (FieldInsnNode) start)) {
			final AbstractInsnNode ifne = start.getNext();
			if (ifne != null && ifne.getOpcode() == Opcodes.IFNE) {
				output.ignore(start, ifne);
			}
		}
	}
}
